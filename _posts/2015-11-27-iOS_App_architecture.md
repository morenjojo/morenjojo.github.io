---
title: "iOS 应用架构"
layout: post
categories: [develop]
tags: [iOS]
excerpt: "常有人说，做移动端的app哪用得着那么麻烦，各种库都是现成的，往项目里一放就好了，何来架构？其实往简单了说，移动端app确实没有服务端那么复杂，性能方面的优化没有服务端那么迫切，拿数据展示数据就是app客户端的基本功能描述（移动端游戏不算）。要是往复杂了说，app客户端也是需要有好的架构的，如果你在一个多人协作的团队，应该会更有体会。接下来就说说iOS应用架构相关的。至于其他平台，技术有所不同但思想应该是一样的。"
---

#app客户端概述
如果你做的是工具类app，不需要依靠网络获取动态数据，那么恭喜，你可以省去很多；  
我所做过的大多数app，基本都是需要网络链接，调用api去获取数据来app展示的；  
简单来说就是调API，展示页面，然后跳转到别的地方再调API，再展示页面；

###app基本功能
- 调用网络api
- 页面展示
- 数据的本地持久化
- 动态不熟方案

###上面几点，细说一下就是：
- 如何让业务开发工程师方便安全地调用网络API？然后尽可能保证用户在各种网络环境下都能有良好的体验？
- 页面如何组织，才能尽可能降低业务方代码的耦合度？尽可能降低业务方开发界面的复杂度，提高他们的效率？
- 当数据有在本地存取的需求的时候，如何能够保证数据在本地的合理安排？如何尽可能地减小性能消耗？
- iOS应用有审核周期，如何能够通过不发版本的方式展示新的内容给用户？如何修复紧急bug？

###上面几点是针对App说的，下面还有一些是针对团队说的：
- 收集用户数据，给产品和运营提供参考
- 合理地组织各业务方开发的业务模块，以及相关基础模块
- 每日app的自动打包，提供给QA工程师的测试工具

#架构设计的方法
1. 搞清楚需要解决的问题
2. 问题分类，分模块
3. 搞清楚各个问题之间的依赖关系，建立好模块交流规范和设计模块
4. 推演预测一下未来可能的走向，必要时添加新的模块，记录更多的基础数据以备未来之需
5. 先解决依赖关系中最基础的问题，实现基础模块，	然后用基础模块堆叠出整个架构
6. 打点，跑单元测试，性能测试，根据数据去优化对应的地方  

总而言之就是要遵循这些原则：`自顶向下设计`（1，2，3，4步），`自底向上实现`（5），`先测量，后优化`（6）。  
#什么才是好的架构师
1 每天都在学习，新技术新思想上手快，理解速度快  
>做不到这一点，你就是码农  

2 业务出身，或者至少非常熟悉公司所处行业或者本公司的业务  
>做不到这点，你还是码农  

3 熟悉软件工程的各种规范，踩过无数坑。不会为了完成需求不择手段，不推崇quick & dirty
>做不到这点，你比较适合去竞争对手那儿当工程师

4 及时承认错误，不要觉得承认错误会有损你架构师的身份
>做不到这点，你还是码农

5 不为了炫技而炫技
>做不到这点，你还是码农

5 精益求精
>做不到这点，你还是码农

#什么样的架构算是好的架构
1. 代码整齐，分类明确，没有common，没有core
2. 不用文档，或很少文档，就能让业务方上手
3. 思路和方法要统一，尽量不要多元
4. 没有横向依赖，万不得已不出现跨层访问
5. 对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件
6. 易测试，易拓展
7. 保持一定量的超前性
8. 接口少，接口参数少
9. 高性能

#架构的分层
**`数据管理者`，`数据加工者`，`数据展示者`**  

三层：`展现层、业务层、数据层`  
四层：`展现层、业务层、网络层、本地数据层`  
>关于这个分层，一开始做架构的时候不要硬往这三层、四层上套，这样是做不出好的架构来的。  
>列出需要解决的问题，针对每个问题设计具体的模块，最后把设计好的模块放在该放的地方，不管是几层架构，最后的分层、结构都会清晰了。

#View层的组织
1. getter和setter全部都放在最后
2. 关于private methods，正常情况下ViewController里面不应该写
3. 设计统一的controller父类，针对每一个生命周期都做特殊设置（比如为以后的数据统计做埋点）`但是，并不建议所有的controller必须继承自这个统一的父类，融合代码会非常困难，推荐多使用AOP`
4. controller自带的view并不能规划到view层，把它叫做View Container更合适

###MVC
M应该做的事：  

1. 给ViewController提供数据
2. 给ViewController存储数据提供接口
3. 提供经过抽象的业务基本组件，供Controller调度

C应该做的事：  

1. 管理View Container的生命周期
2. 负责生成所有的View实例，并放入View Container
3. 监听来自View与业务有关的事件，通过与Model的合作，来完成对应事件的业务

V应该做的事：  

1. 响应与业务无关的事件，并因此引发动画效果，点击反馈（如果合适的话，尽量还是放在View去做）等
2. 界面元素表达

###MVCS
苹果自身就采用的是这种架构思路，从名字也能看出，也是基于MVC衍生出来的一套架构。从概念上来说，它拆分的部分是Model部分，拆出来一个Store。这个Store专门负责数据存取。但从实际操作的角度上讲，它拆开的是Controller。  

什么叫胖Model？  

>胖Model包含了部分弱业务逻辑。胖Model要达到的目的是，Controller从胖Model这里拿到数据之后，不用额外做操作或者只要做非常少的操作，就能够将数据直接应用在View上

什么叫瘦Model？  

>瘦Model只负责业务数据的表达，所有业务无论强弱一律扔到Controller。瘦Model要达到的目的是，尽一切可能去编写细粒度Model，然后配套各种helper类或方法来对弱业务做抽象，强业务依旧交给Controller

###MVVM
MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel。关于这个观点我要做一个额外解释：胖Model做的事情是先为Controller减负，然后由于Model变胖，再在此基础上拆出ViewModel，跟业界普遍认知的MVVM本质上是为Controller减负这个说法并不矛盾，因为胖Model做的事情也是为Controller减负。  

那么MVVM究竟应该如何实现？  

>MVVM的关键是要有View Model！而不是ReactiveCocoa  
>  
> 不用ReactiveCocoa也能MVVM，用ReactiveCocoa能更好地体现MVVM的精髓  
>   
> 所以Controller在MVVM中，一方面负责View和ViewModel之间的绑定，另一方面也负责常规的UI逻辑处理。

###跨业务页面调用方案的设计
跨业务页面调用是指，当一个App中存在A业务，B业务等多个业务时，B业务有可能会需要展示A业务的某个页面，A业务也有可能会调用其他业务的某个页面。在小规模的App中，我们直接import其他业务的某个ViewController然后或者push或者present，是不会产生特别大的问题的。但是如果App的规模非常大，涉及业务数量非常多，再这么直接import就会出现问题。  

那么应该怎样处理这个问题？  

>让依赖关系下沉。

怎么让依赖关系下沉？引入Mediator模式。

所谓引入Mediator模式来让依赖关系下沉，实质上就是每次呼唤页面的时候，通过一个中间人来召唤另外一个页面，这样只要每个业务依赖这个中间人就可以了，中间人的角色就可以放在业务层的下面一层，这就是依赖关系下沉。

###View组织架构总结
1. 制定良好的规范
2. 选择好合适的模式（MVC、MVCS、MVVM、VIPER）
3. 根据业务情况针对ViewController做好拆分，提供一些小工具方便开发

#关于AOP
什么是切片？  

>程序要完成一件事情，一定会有一些步骤，1，2，3，4这样。这里分解出来的每一个步骤我们可以认为是一个切片。

什么是面向切片编程？  

>你针对每一个切片的间隙，塞一些代码进去，在程序正常进行1，2，3，4步的间隙可以跑到你塞进去的代码，那么你写这些代码就是面向切片编程。

为什么会出现面向切片编程？  

>你要想做到在每一个步骤中间做你自己的事情，不用AOP也一样可以达到目的，直接往步骤之间塞代码就好了。但是事实情况往往很复杂，直接把代码塞进去，主要问题就在于：塞进去的代码很有可能是跟原业务无关的代码，在同一份代码文件里面掺杂多种业务，这会带来业务间耦合。为了降低这种耦合度，我们引入了AOP。

如何实现AOP？  

>AOP一般都是需要有一个拦截器，然后在每一个切片运行之前和运行之后（或者任何你希望的地方），通过调用拦截器的方法来把这个jointpoint扔到外面，在外面获得这个jointpoint的时候，执行相应的代码。

#网络层设计
##网络层跟业务对接部分的设计
###使用哪种交互模式来跟业务层做对接？
以什么方式将数据交付给业务层？  

>iOS开发领域有很多对象间数据的传递方式，我看到的大多数App在网络层所采用的方案主要集中于这三种：Delegate，Notification，Block。KVO和Target-Action我目前还没有看到有使用的。

>目前我知道边锋主要是采用的block，大智慧主要采用的是Notification，安居客早期以Block为主，后面改成了以Delegate为主，阿里没发现有通过Notification来做数据传递的地方（可能有），Delegate、Block以及target-action都有，阿里iOS App网络层的作者说这是为了方便业务层选择自己合适的方法去使用。这里大家都是各显神通，每次我看到这部分的时候，我都喜欢问作者为什么采用这种交互方案，但很少有作者能够说出个条条框框来。

  
**`建议以Delegate为主，Notification为辅`**  

- 尽可能减少跨层数据交流的可能，限制耦合
- 统一回调方法，便于调试和维护
- 在跟业务层对接的部分只采用一种对接手段（在我这儿就是只采用delegate这一个手段）限制灵活性，以此来交换应用的可维护性

为什么尽量不要用block？  

>block很难追踪，难以维护
>
>block会延长相关对象的生命周期

**尽可能通过Delegate的回调方式交付数据，这样可以避免不必要的跨层访问。  
当出现跨层访问的需求时（比如信号类型切换），通过Notification的方式交付数据。  
正常情况下应该是避免使用Block的。**

交付什么样的数据给业务层？  

>对于业务层而言，由Controller根据View和APIManager之间的关系，选择合适的reformer将View可以直接使用的数据（甚至reformer可以用来直接生成view）转化好之后交付给View。对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型。然后数据采用NSDictionary加Const字符串key来表征，避免了使用对象来表征带来的迁移困难，同时不失去可读性。

###集约型API调用方式和离散型API调用方式的选择？
- 集约型API调用其实就是所有API的调用只有一个类，然后这个类接收API名字，API参数，以及回调着陆点（可以是target-action，或者block，或者delegate等各种模式的着陆点）作为参数。然后执行类似startRequest这样的方法，它就会去根据这些参数起飞去调用API了，然后获得API数据之后再根据指定的着陆点去着陆。

- 离散型API调用是这样的，一个API对应于一个APIManager，然后这个APIManager只需要提供参数就能起飞，API名字、着陆方式都已经集成入APIManager中。

**综上，关于集约型的API调用和离散型的API调用，我倾向于这样：对外提供一个BaseAPIManager来给业务方做派生，在BaseManager里面采用集约化的手段组装请求，放飞请求，然而业务方调用API的时候，则是以离散的API调用方式来调用。如果你的App只提供了集约化的方式，而没有离散方式的通道，那么我建议你再封装一层，便于业务方使用离散的API调用方式来放飞请求。**

###小结
1. 使用delegate来做数据对接，仅在必要时采用Notification来做跨层访问
2. 交付NSDictionary给业务层，使用Const字符串作为Key来保持可读性
3. 提供reformer机制来处理网络层反馈的数据，这个机制很重要，好处极多
4. 网络层上部分使用离散型设计，下部分使用集约型设计
5. 设计合理的继承机制，让派生出来的APIManager受到限制，避免混乱

##网络层的安全机制
1. 签名
2. HTTPS

这一节说了两种安全机制，一般来说第一种是标配，第二种属于可选配置。不过随着我国互联网基础设施的完善，移动设备性能的提高，以及优化技术的提高，第二种配置的缺点（速度慢）正在越来越微不足道，因此HTTPS也会成为不久之后的未来App的网络层安全机制标配。各位架构师们，如果你的App还没有挂HTTPS，现在就已经可以开始着手这件事情了。

##网络层优化
1 使用缓存（本地数据缓存）和使用策略（同一个用户操作触发的同一个请求，比如频繁的下拉刷新），来减少请求的发起次数

>针对建立连接这部分的优化就是这样的原则：能不发请求的就尽量不发请求，必须要发请求时，能合并请求的就尽量合并请求。然而，任何优化手段都是有前提的，而且也不能保证对所有需求都能起作用，有些API请求就是不符合这些优化手段前提的，那就老老实实发请求吧。不过这类API请求所占比例一般不大，大部分的请求都或多或少符合优化条件，所以针对发送请求的优化手段还是值得做的。

2 动态获取ip，而不是靠dns去解析ip

>本地有一份IP列表，这些IP是所有提供API的服务器的IP，每次应用启动的时候，针对这个列表里的所有IP取ping延时时间，然后取延时时间最小的那个IP作为今后发起请求的IP地址。 
>
>实现：[可以参考这里](http://nshipster.com/nsurlprotocol/) [基于NSURLProtocol的工具](https://github.com/mattt/NSEtcHosts)

###参考代码
[RTNetworking](https://github.com/casatwy/RTNetworking)

#心得
1. 代码规范很重要，controller如何组织都要有讲究
2. 如何架构能更有效的降低团队间代码冲突
3. 如何做好跨业务页面逻辑调用，减少横向依赖（只需要明确一个目的地url就可以展示一个页面，项目中的url page manager 就是一个Mediator）
4. controller如何解决网络层带来的该释放不释放问题 (适时的切断与网络层的通信)
5. 网络层基础架构需要`集约型设计`，业务层逻辑适合`离散型设计`

###参考
- [iOS应用架构谈](http://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html)